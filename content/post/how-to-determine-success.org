#+TITLE: Appreciate your Constraints
#+DATE: 2019-08-01
#+DRAFT: true
#+TAGS: guide thoughts

Many engineers want to measure the quality and effectiveness of their work. They
turn to code coverage, burn down charts, and yearly goals, with the best
intention.

The metrics they gather provide quantitative data about how much work got done
and if what was planned got delivered, but they fail to tie the work to the
outcome. What good are 1,000 lines of code if the user never uses the
feature? These metrics distract from the two question every professional
should ask:

Did my work deliver measurable changes?

Did I stay within the constraints?

Everyone is familiar with the concept of measurable results. Others have written
and talked extensively on how to measure the right thing. <provide links>

But the second question, about constraints, may come as a surprise. As
engineers we have an averssion to constraints. In reality, however, it's not the
engineer that finds the best new tool that's viewed as an expert, it's the
engineer that gets amazing results with what's right in front of him.

As we dive down the rabbit hole of new tools in search of perfection -- timeline
double, bugs get introduced, and the whole project comes to a screeching halt
because of the mountain of tech debt we built up.

The expert engineer, on the other hand, keeps the introductions of new tools
small. He doesn't pull in a library for left pad because he knows how to write
that code quickly. His scope for new bugs is small so even if he introduces one
he can quickly find and fix it, in his own code. 

OK, most of the time the search for new tools doesn't get that bad, and the expert
engineer is only a fable. But the price of searching for perfect is very real,
and we should strive to be more like the expert engineer. 

In this article I want to cover the constraints I had to deal with in my
career and the techniques I found to dealing with them.
** Not Enough Time
Whether a bug came up, an outage happened, or we just underestimated a work, we
constantly come up against time constraints. It's the nature of the job when
working in an unstructured domain with a high level of complexity. 

The easy solution is push back the feature. We can finish it at the beginning of
next sprint because we work in small increments... Or at least we should. In my
experience, time constraints rarely become an issue if the tasks are kept small.
No one gets upset if we continue to deliver some improvements to the system.

Time constraints become an issue when we bite off a bigger chunk than we can
handle. When the timeline is up and we have nothing to show, we might be just
one pesky bug away from shipping the whole feature. But are we sure there isn't
another bug lurking after this one? 

When you realize you picked up too much work stop. Instead of working late
nights or taking your chances, break up the story. See if there are smaller
chunks that deliver value hidden underneath all your work. You might have
already implemented one of them. That's your deliverable.

By having something to delivery, you make headway in this iteration and you set
clear expectations for the next one. The stake holders are happy they got some
features, and you get the time to finish the feature properly.
** Missing Requirements
If you are not sure what you need to do, stop. It's better to clarify and make
sure you are delivering value than to add unnecessary complexity or throw away
your work.

There are two possible outcome when you ask for clarification: what you are
working on is a high priority and you get clarification right away, or you can't
get anyone to look at it at the moment. The latter indicates that what you're
working on isn't not priority. So go to your backlog and pick up the next top
priority item, there is always more work. Once the original task becomes
important, you can get clarification.
** Changing Requirements
Changing requirements on a top priority item can cause you a headache and
continuous rewrites. You might be tempted to follow the advice of the previous
two suggestions, but that will be counterproductive here.

When the item is important but the requirements aren't clear it indicates a
level of complexity that can't be easily imagined without a working
implementation. That's where you can help.

Create a few low effort implementation of the proposed solutions and let the
users try them out. You can even use fake data to speed things up. Once they
settle on an option, solidify the implementation and integrate it as a
full feature of the product.
** Unrealistic Expectations
If you work with a large number of non-technical users, they might have
unrealistic expectations. "It will only take a couple hours to add
authentication, right?"

Don't get frustrated by these requests. This is your chance to show your
expertise. You have you clearly explain what makes the feature complicated and
give a scope of work. You will find it helpful to compare it to the other top
priority items.

Once the stake holders know the work required, they will give you more time or
pick a feature that they can have sooner. The important part is, you relieve
the pressure to rush and leave behind a mess that may never get cleaned up.
** The Right Tool for the Job
The notion of "the right tool for the job" echoes through every office.
Unfortunately, it gets misunderstood almost as often as it gets uttered.

*Right* doesn't mean perfect. It means that the tool enables you to accomplish
the job without wasting your time or requiring lots of upfront work. It can even
competely changed depending on the person or the team.

If a team knows nothing about a language used to implement the perfect tool for
their use case, the cost may be too high. They could spend weeks learning how to
get to the solution. Where as if they pick a library in their prefered language
that gets them 80% there, they will accomplish the task while only incurring a
minor burden.
** Limitations of Technology
This is the most surprising are of frustration for people. When you reach a
technological limitation -- like processing speed, memory limits, rendering
speed -- it's not time to dispaire. It's time to celebrate. You finally get to
dust off that old book on algorithms and pull out all the knowledge from your
degree, if you have one. 

These challenges don't come along too often for most of us. If you are lucky
enough to find one of these, dive in and enjoy what you will learn. 
