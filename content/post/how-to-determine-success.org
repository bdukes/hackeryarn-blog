#+TITLE: Appreciate your Constraints
#+DATE: 2019-08-01
#+DRAFT: true
#+TAGS: guide thoughts

Many engineers want to measure the quality and effectiveness of their work. They
turn to code coverage reports, burn down charts, and yearly goals with the best
intention. However, these metrics only get them part of they way. 

These surface level metrics provide quantitative data about how much work gets
done, but they fail to tie these metrics to a meaningful outcome. They miss out
on the two most meaningful questions they could ask.

Did my work deliver measurable changes?

Did I stay within constraints?

Everyone is familiar with the concept of measurable results. Others have written
and talked extensively on how to measure the right thing, so I won't go into
that here. <provide links>

But the second question may come as a surprise. As engineers we have an averssion to
constraints. We always try to find a way to free ourselves of them, or at least
loosen the constraints, often through new tools.

As we dive down the rabbit hole for the search of perfection -- timeline double,
bugs get introduced, and the whole project comes to a screeching halt because
of the mountain of tech debt we built up.

OK, most of the time it doesn't get that bad, but the price of searching for
perfect is very real. That's why the best engineers stay within the constraints
while still delivering the most value possible.

In this article I want to cover the common constraints developers deal with
every day and provide advice on dealing with them.
** Not Enough Time
Whether a bug came up, an outage happened, or we just underestimated a work, we
constantly come up against time constraints. It's the nature of the job when
working in an unstructured domain with a high level of complexity. 

The easy solution is push back the feature. We can finish it at the beginning of
next sprint because we work in small increments... Or at least we should. In my
experience, time constraints rarely become an issue if the tasks are kept small.
No one gets upset if we continue to deliver some improvements to the system.

Time constraints become an issue when we bite off a bigger chunk than we can
handle. When the timeline is up and we have nothing to show, we might be just
one pesky bug away from shipping the whole feature. But are we sure there isn't
another bug lurking after this one? 

When you realize you picked up too much work stop. Instead of working late
nights or taking your chances, break up the story. See if there are smaller
chunks that deliver value hidden underneath all your work. You might have
already implemented one of them. That's your deliverable.

By having something to delivery, you make headway in this iteration and you set
clear expectations for the next one. The stake holders are happy they got some
features, and you get the time to finish the feature properly.
** Missing Requirements
If you are not sure what you need to do, stop. It's better to clarify and make
sure you are delivering value than to add unnecessary complexity or throw away
your work.

There are two possible outcome when you ask for clarification: what you are
working on is a high priority and you get clarification right away, or you can't
get anyone to look at it at the moment. The latter indicates that what you're
working on isn't not priority. So go to your backlog and pick up the next top
priority item, there is always more work. Once the original task becomes
important, you can get clarification.
** Changing Requirements
Changing requirements on a top priority item can cause you a headache and
continuous rewrites. You might be tempted to follow the advice of the previous
two suggestions, but that will be counterproductive here.

When the item is important but the requirements aren't clear it indicates a
level of complexity that can't be easily imagined without a working
implementation. That's where you can help.

Create a few low effort implementation of the proposed solutions and let the
users try them out. You can even use fake data to speed things up. Once they
settle on an option, solidify the implementation and integrate it as a
full feature of the product.
** Unrealistic Expectations
If you work with a large number of non-technical users, they might have
unrealistic expectations. "It will only take a couple hours to add
authentication, right?"

Don't get frustrated by these requests. This is your chance to show your
expertise. You have you clearly explain what makes the feature complicated and
give a scope of work. You will find it helpful to compare it to the other top
priority items.

Once the stake holders know the work required, they will give you more time or
pick a feature that they can have sooner. The important part is, you relieve
the pressure to rush and leave behind a mess that may never get cleaned up.
** The Right Tool for the Job
The notion of "the right tool for the job" echoes through every office.
Unfortunately, it gets misunderstood almost as often as it gets uttered.

*Right* doesn't mean perfect. It means that the tool enables you to accomplish
the job without wasting your time or requiring lots of upfront work. It can even
competely changed depending on the person or the team.

If a team knows nothing about a language used to implement the perfect tool for
their use case, the cost may be too high. They could spend weeks learning how to
get to the solution. Where as if they pick a library in their prefered language
that gets them 80% there, they will accomplish the task while only incurring a
minor burden.
