#+TITLE: Appreciate The Constraints
#+DATE: 2019-08-01
#+DRAFT: true
#+TAGS: thoughts practices

Many engineers want to measure the quality and effectiveness of their work. They
turn to code coverage, burn down charts, and yearly goals, with the best
intention.

These metrics provide quantitative data about how much planned work was
delivered, but they fail to tie the work to outcome. What good are 1,000
lines of code if the users never use the feature? These metrics distract from
the two question every professional should ask:

- Did my work deliver measurable change?

- Did I stay within the constraints?

Everyone is familiar with the concept of measurable results. Others have written
and talked extensively on how to measure the right thing. <provide links>

But the second question, around constraints, may come as a surprise. As
engineers we have an aversion to constraints. We think they limit the quality of
the solutions we deliver.

In reality, it's not the engineer that finds the best new tool that's highly
regarded, it's the one that gets the results with what's right in front of
him. The developer that mastered his domain brings more value.

As we dive down the rabbit hole of new tools in search of perfection: timeline
double, bugs get introduced, and the whole project comes to a screeching halt
because of the mountain of tech debt.

The expert engineer, on the other hand, is careful about introducing new tools.
He doesn't pull in a library for left pad because he knows how to write
that code. His scope for new bugs is small so when he introduces one he can
quickly find and fix it, in his own code.

OK, most of the time the search for new tools doesn't get that bad, and the expert
engineer is a myth. But the price of always looking for the easy way is very
real, and we should strive to be more like the expert engineer.

In this article I want to cover the most common constraints I had to deal with
and provide the techniques I found to dealing with them.
** Not Enough Time
Whether a bug came up, an outage happened, or we just underestimated the work,
we constantly come up against time constraints. It's the nature of the job when
working in a highly complex domain.

The easy solution is pushing back the feature. We can finish it at the beginning of
next sprint because we work in small increments... Right?

In my experience, time constraints rarely become an issue if the tasks are kept
small. No one gets upset if features are delivered at the end of each iteration,
even if it's not all the promised ones.

Time constraints become an issue when we take on too much work at once. When the
timeline is up and we have nothing to show. We might have been one bug away from
delivering the features, but that doesn't matter if the stake holders get
nothing.

To prevent this situation, you have to break the all or nothing mentality. When
you realize the task you're working on is too much, stop. Reevaluate what the
requirement are, even go back to the stakeholders.

Figure out the small chunk of work that will bring the most value. Pareto principle
states that 20% of the work holds 80% of the value. When features bloat, it's up
to you to figure out the 20% that will deliver 80% of the value. Then you can
revisit the other 80% later, if it's still needed.
** Missing or Changing Requirements
Before you can be effective you need to have clarity of the expectations. To get
clarity you need to ask questions.

Your question will result in three possible outcomes:

If the feature is high priority, you will get to have the needed conversation 
and gain clarity. This will let you start work with a better idea of what's
expected and minimum down time.

A much worse outcome, but all too possible, is that you can't get anyone to look
at the feature. When this happens you should question the priorities. If it's
not a high enough priority to define well, it shouldn't be a high enough
priority to work on. The work is endless, your time isn't. See what else is
needed and select something that you can accomplish.

The third options, and the one you stand you gain the most from, is when the
feature is high priority but the users and stakeholders aren't sure what they
want. You get the chance to create low fidelity prototypes, explore new
techniques and approaches, and get into a creative mindset. Working through this
process with the users allows you learn about them. Times like this result in
better understanding on all the work going forward. The return on investment of
this time is enormous. 
** Unrealistic Expectations
If your users and stake holders are non-technical, like they often are, you will
inevitably come up against ridiculous expectations. "It will only take a couple
hours to add authorization, right?" These expectation may even be your own
doing. If your application is well build and easy to use, it becomes
indistinguishable from magic. Everything seems easy from the outside.

So don't get frustrated by these requests. They are another chance for you to
connect with your users. This time, allow them to understand more about your
work. Compare the other features to the current features and explain why this
feature might take longer than another. 

Once the stake holders know the work required, they will give you more time or
pick a feature they can have sooner. The important part is, you relieve
the pressure to rush and you educated the users so next time they know the scope
of that type of feature.
** The Right Tool for the Job
The notion of "the right tool for the job" echoes through every office.
Unfortunately, it's misunderstood almost as often as it gets uttered.

*Right* doesn't mean perfect. It means the tool that enables you to accomplish
the job without wasting time. It even changes depending on the person or team.

If a team knows nothing about a language used to implement the perfect tool,
they could spend weeks learning how to get to the solution. Sure future work may
get easier, but will the amount of future work justify the investment right now.

On the other hand, if they use the language they know and add library that gets
them 80% of the way there, they will accomplish the task with a minor delay.
This will get your users results, and you can always come back to evaluate that
perfect tool later.

No matter which option you pick, remember that every new tool needs careful
consideration. Your team has to learn the tool. You have to make sure the
tool is maintained, or has clean code so you could take on the maintenance. You
have to verify that it works with the rest of your dependencies. If this sounds
like too much work, consider implementing feature you need yourself.
** Technological Limitations
This is the most surprising area of frustration. Many of us have gone to school
-- or spent vast amount of time -- to learn about optimizations, data
structures, and algorithms. We learned about these so we could deal with
technological limitation.

When you reach a technological limitation -- like processing speed, memory
limits, rendering speed -- it's not time to dispaire. It's time to celebrate.
You finally get to dust off your old book and figure out a really tough problem.

The important part, for those you work with, is to set realistic expectations.
There won't be a quick solution. If you really need to overcome this problem,
it will take a significant time investment. 

Once the expectations are set and you get to start this work, consider yourself
lucky. These challenges don't come along often. So dive in and enjoy what you
will learn.
** Wrap Up
This isn't an exhaustive list of constraints you will face. These are just the
once I find myself frustrated with the most.

I hope that this list will serve as a reminder to you and me about how lucky we
are to work in a field that allows us to solve problems every day. To enjoy the
process, we just have to expand our scope of what problems we are solving.
