#+TITLE: Why I Use Emacs in 2019
#+DATE: 2019-05-xx
#+DRAFT: true
#+CATEGORIES: Emacs 
#+TAGS: guide emacs

A few months ago, Gabriel Gonzalez wrote an [[http://www.haskellforall.com/2018/10/detailed-walkthrough-for-beginner.html][excellent article]] on getting started
creating useful tools with Haskell. He used an example of a small CLI tool meant
to align the equals signs of a multi-line text input. Then he demonstrate how it
can be used from vim to format a region of text.

I love the overarching concept in the article: create small tools that can be
reused. This is directly inline with the Unix philosophy. And I was on board
with the Gabriel's approach, except I am an Emacs user. 

So in this article, I wanted to show how I combine Emacs with anything that runs
on the command line.

This combination allows me to write scripts that do complicated work in the
language best suited for the job. The scripts are written in a reusable way so
they could be run directly from the command line, from a CI build, or from a
text editor. Then I can write a little elisp to integrate the scripts with
Emacs.

* Taking an action on a region

This is the scenario Gabriel uses in his article. You select a region and run
a command on it's contents. The output of the command replaces the selected region.

The command we will use is the one Gabriel implemented, ~align-equals~. If you
want to see the implementation, and learn a little about Haskell, you can read
his [[http://www.haskellforall.com/2018/10/detailed-walkthrough-for-beginner.html][article]]. Here is the CLI usage of the command:

#+begin_src bash
$ ./align-equals
  foo = 1
  a = 2
  asdf = 3
  <Ctrl-D>
  foo  = 1
  a    = 2
  asdf = 3
#+end_src

We could run this program on a region with the built in
~shell-command-on-region~, and that would work fine for this example. However,
we often need to pass arguments to a function and that's when I like to write a
small wrapper. Also we could automatically execute the wrapper function under
specific conditions. More on this later in the article.


To create the wrapper, we need to combine a couple elisp components. we start
our function by expecting the beginning and ending of the region as arguments.
We get those arguments by specifying the region(~r~) flag for the ~interactive~
function. This function supports [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Interactive-Codes.html#Interactive-Codes][many options]] that allow it to grab arguments
from different contexts.

Having our region bounds, we call ~shell-command-on-region~ which, as the name
suggests, executes a shell command on a region specified by the beginning and
ending arguments passed to it. It then takes the shell command to execute, and
two flags which specify that the region should be replaced by the command
output. 

The short function looks like this:

#+begin_src elisp
(defun align-equals (b e) 
  (interactive "r")
  (shell-command-on-region b e "align-equals" t t))
#+end_src

This wrapper enables us to pass in any arguments we may need to the CLI
function, and we can invoke it with a since call to ~<M-x> align-equals~.

* Take action on the buffer

A common scenario I run into, is wanting to run a tool on the whole file. This
normally comes in two variants. I either want to modify the content of the file
in some way, like using a beautifier. Or I want to produce an output based on
the file content, like getting totals or showing lint errors.

Again, there are built in ways to do this, but a wrapper lets us do more with
our shell command.

** Replacing buffer contents
   
For this purpose we can reuse ~shell-command-on-region~ while grabbing the
~point-min~ and ~point-max~ -- the start and end of the buffer respectively.

#+begin_src elisp
(defun align-buffer ()
  (interactive)
  (shell-command-on-region (point-min) (point-max) "align-equals" t t))
#+end_src

This time, we don't need to have any parameters or pass an arguments to the
~interactive~. 

To use this command, we can invoke it with ~<M-x> align-buffer~ from anywhere in
the buffer we wan to align. This make the command quick to run. 

**  Displaying output of a shell command

Other times you want to see the output a shell command, like when running a
linter or build tool. 

Let's use ~eslint~ -- a popular tool for linting JavaScript code. ~eslint~ takes
a file name, and not the buffer content like our previous command. We can use
the built in ~buffer-name~ function to get the name of the ~current-buffer~.
Once we have the name, we pass it to the ~eslint~ program. We use the
~shell-command~ variant for simply running the command and logging the output.

#+begin_src elisp
(defun run-eslint ()
  (interactive)
  (let ((current-file (buffer-name (current-buffer))))
    (shell-command (concat "eslint " current-file))))
#+end_src

Now we can execute ~run-eslint~ in any JavaScript file and see the results of
executing the command. 

Seeing the results lets us manually fix the issues ourselves, but ~eslint~ comes
with a handy ~--fix~ flag that will automatically fix simple problems. Then we
can work through the more complicated errors from our output buffer.

To add this flag you only need to change the ~shell-command~ line. 

#+begin_src elisp
    (shell-command (concat "eslint --fix" current-file))))
#+end_src

* Running Command Automatically
  
We have a useful ~run-eslit~ function now, but we need to run it manually every
time we want to execute it. Wouldn't it be nice to run it automatically, every
time we save a file? 

There are two facilities that makes automatic function execution precise and
safe: modes and hooks.

Modes allow us to know what context we are in. For example ~run-eslint~ should
only run when we are editing JavaScript files. Therefore, we need to setup our
hook to only execute in ~js-mode~.

Hooks let us run actions when specific events happen. To accomplish our goal, we
will use two types of hooks. A mode hook, which lets us enable a functionality
only when the specified mode is active, sepcifically ~js-mode-hook~. And an
action hook, which executes a function when a user performs a specific action.
In our case we will use the ~on-save-hook~.
